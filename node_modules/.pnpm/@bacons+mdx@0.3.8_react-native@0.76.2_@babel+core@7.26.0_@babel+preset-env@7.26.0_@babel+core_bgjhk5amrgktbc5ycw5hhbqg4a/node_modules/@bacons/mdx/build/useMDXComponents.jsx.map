{"version":3,"file":"useMDXComponents.jsx","sourceRoot":"","sources":["../src/useMDXComponents.tsx"],"names":[],"mappings":";;;;;;AAAA,kDAA0B;AAE1B,mDAA2D;AAC3D,2CAA2C;AAE3C,qCAAqC;AACrC,SAAgB,gBAAgB;IAC9B,MAAM,MAAM,GAAG,IAAA,wBAAY,GAAE,CAAC;IAC9B,MAAM,UAAU,GAAG,IAAA,wCAAwB,GAAE,CAAC;IAC9C,6CAA6C;IAC7C,MAAM,GAAG,GAAG,MAAM,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC,MAAM,CAAC,CAAC,GAAG,EAAE,GAAG,EAAE,EAAE;QACtD,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,KAAK,EAAE,EAAE;YACnB,IAAI,OAAO,UAAU,CAAC,GAAG,CAAC,KAAK,UAAU,EAAE;gBACzC,OAAO,UAAU,CAAC,GAAG,CAAC,CAAC,EAAE,GAAG,KAAK,EAAE,KAAK,EAAE,MAAM,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC;aAC1D;YACD,OAAO,eAAK,CAAC,aAAa,CAAC,UAAU,CAAC,GAAG,CAAC,EAAE;gBAC1C,GAAG,KAAK;gBACR,KAAK,EAAE,MAAM,CAAC,GAAG,CAAC;aACnB,CAAC,CAAC;QACL,CAAC,CAAC;QACF,OAAO,GAAG,CAAC;IACb,CAAC,EAAE,EAAE,CAAC,CAAC;IAEP,8EAA8E;IAC9E,OAAO,eAAe,CAAC,GAAG,CAAC,CAAC;AAC9B,CAAC;AAnBD,4CAmBC;AAED,SAAS,eAAe,CAAC,UAA+B;IACtD,OAAO,IAAI,KAAK,CAAC,UAAU,EAAE;QAC3B,GAAG,CAAC,MAAM,EAAE,IAAI;YACd,IAAI,OAAO,IAAI,KAAK,QAAQ,EAAE;gBAC5B,OAAO;aACR;YACD,IAAI,IAAI,IAAI,MAAM,IAAI,MAAM,CAAC,IAAI,CAAC,EAAE;gBAClC,OAAO,MAAM,CAAC,IAAI,CAAC,CAAC;aACrB;YACD,oGAAoG;YACpG,IAAI,IAAI,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,OAAO,CAAC,EAAE;gBAC1B,MAAM,IAAI,KAAK,CACb,oCAAoC,IAAI,wEAAwE,IAAI,2BAA2B,CAChJ,CAAC;aACH;YACD,oEAAoE;QACtE,CAAC;KACF,CAAC,CAAC;AACL,CAAC","sourcesContent":["import React from \"react\";\n\nimport { useInternalMDXComponents } from \"./MDXComponents\";\nimport { useMDXStyles } from \"./MDXStyles\";\n\n/** Get the composed MDX elements. */\nexport function useMDXComponents() {\n  const styles = useMDXStyles();\n  const components = useInternalMDXComponents();\n  // Mix the context styles into the components\n  const obj = Object.keys(components).reduce((acc, key) => {\n    acc[key] = (props) => {\n      if (typeof components[key] === \"function\") {\n        return components[key]({ ...props, style: styles[key] });\n      }\n      return React.createElement(components[key], {\n        ...props,\n        style: styles[key],\n      });\n    };\n    return acc;\n  }, {});\n\n  // Wrap with a proxy to add better error messages when a component is missing.\n  return withProxyErrors(obj);\n}\n\nfunction withProxyErrors(components: Record<string, any>) {\n  return new Proxy(components, {\n    get(target, prop) {\n      if (typeof prop !== \"string\") {\n        return;\n      }\n      if (prop in target && target[prop]) {\n        return target[prop];\n      }\n      // If the prop starts with a lowercase letter, it's not a missing built-in component (internal bug).\n      if (prop[0].match(/[a-z]/)) {\n        throw new Error(\n          `No MDX component found for key: \"${prop}\". Define it using the React provider: <MDXComponents components={{ \"${prop}\": () => <Text ... /> }}>`\n        );\n      }\n      // For components, depend on the transform to add the error message.\n    },\n  });\n}\n"]}