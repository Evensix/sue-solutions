"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createMissingView = void 0;
const react_1 = __importDefault(require("react"));
const NativeView = (props) => react_1.default.createElement("RCTView", props);
const Text = (props) => react_1.default.createElement("RCTText", props);
class Try extends react_1.default.Component {
    constructor() {
        super(...arguments);
        this.state = { error: undefined };
    }
    static getDerivedStateFromError(error) {
        return { error };
    }
    render() {
        const { error } = this.state;
        const { catch: ErrorBoundary, children } = this.props;
        if (!error) {
            return children;
        }
        return react_1.default.createElement(ErrorBoundary, { error });
    }
}
function ErrorBoundary({ error }) {
    var _a;
    if (error.message) {
        // When a DOM component is rendered inside a node module that shipped without the jsx-runtime, we can only intercept the error from the renderer.
        const invalidComponentName = (_a = error.message.match(/View config getter callback for component `([^`]+)`/)) === null || _a === void 0 ? void 0 : _a[1];
        // Prevent wrapping the error for rendering an undefined component.
        if (String(invalidComponentName) !== "undefined") {
            return react_1.default.createElement(Text, { style: { color: "red" } }, [
                `Unsupported DOM <${invalidComponentName} />`,
            ]);
        }
    }
    return react_1.default.createElement(Text, { style: { color: "red" } }, [
        error.message,
    ]);
}
function createMissingView(name) {
    const stackItem = (src) => {
        if (typeof src === "object" && src && "fileName" in src) {
            let trace = src.fileName;
            if ("lineNumber" in src) {
                trace += ":" + src.lineNumber;
            }
            if ("columnNumber" in src) {
                trace += ":" + src.columnNumber;
            }
            return trace;
        }
        return "";
    };
    // Add better errors and warnings in development builds.
    const View = function View(props) {
        react_1.default.useEffect(() => {
            const { $$source } = props;
            console.error(`Unsupported DOM <${name} /> at: ${stackItem($$source)}\nThis will break in production.`);
        }, []);
        const children = react_1.default.useMemo(() => {
            const children = [];
            react_1.default.Children.forEach(props.children, (child, index) => {
                if (child == null) {
                    return;
                }
                if (typeof child === "string") {
                    // Wrap children with Text to prevent cryptic React errors when we already have a useful warning about the missing DOM element.
                    children.push(react_1.default.createElement(Text, { key: String(index) }, [child]));
                }
                else {
                    children.push(child);
                }
            });
            return children;
        }, [props.children]);
        return react_1.default.createElement(NativeView, props, react_1.default.createElement(Try, { catch: ErrorBoundary }, children));
    };
    // Make the component stack show the name of the missing dom element.
    View.displayName = `MISSING(${name})`;
    return View;
}
exports.createMissingView = createMissingView;
//# sourceMappingURL=MissingDomView.jsx.map