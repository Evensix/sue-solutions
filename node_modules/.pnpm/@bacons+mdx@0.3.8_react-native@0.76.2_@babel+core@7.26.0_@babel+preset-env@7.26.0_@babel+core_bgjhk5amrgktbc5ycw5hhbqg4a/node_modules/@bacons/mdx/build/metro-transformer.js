"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.transform = exports.createTransformer = void 0;
const mdx_1 = __importDefault(require("@mdx-js/mdx"));
const unist_util_visit_1 = __importDefault(require("unist-util-visit"));
const debug = require("debug")("bacons:mdx:transform");
const getTemplate = (rawMdxString) => {
    const replacedShortcodes = rawMdxString.replace(/= makeShortcode\(/g, "= makeExpoMetroProvided(");
    return `import { useMDXComponents } from "@bacons/mdx";
${makeExpoMetroProvidedTemplate}
${replacedShortcodes.replace("return <MDXLayout", "const html = useMDXComponents();\n  const MDXLayout = html.Wrapper;\n  return <MDXLayout")}`;
};
const makeExpoMetroProvidedTemplate = `
const makeExpoMetroProvided = name => function MDXExpoMetroComponent(props) {
  const html = useMDXComponents();
  if (html[name] == null) {
    console.warn("Component " + name + " was not imported, exported, or provided by MDXProvider as global scope")
    return <html.span {...props}/>
  }
  return html[name](props);
};`;
function isParent(node) {
    return Array.isArray(node === null || node === void 0 ? void 0 : node.children);
}
function createTransformer({ matchFile = (props) => !!props.filename.match(/\.mdx?$/), matchLocalAsset = (props) => !!props.src.match(/^[.@]/), remarkPlugins = [], } = {}) {
    const compiler = mdx_1.default.createCompiler({ remarkPlugins });
    // Append this final rule at the end of the compiler chain:
    compiler.use(() => {
        return (tree, _file) => {
            if (isParent(tree)) {
                const walkForImages = (node) => {
                    if (node.tagName === "img") {
                        if (matchLocalAsset(node.properties)) {
                            // Relative path should be turned into a require statement:
                            node.properties.src = `[[_Expo_MemberProperty:require("${node.properties.src}")]]`;
                            // delete node.properties.src;
                        }
                    }
                    if (isParent(node)) {
                        node.children.forEach(walkForImages);
                    }
                };
                tree.children.map(walkForImages);
            }
            (0, unist_util_visit_1.default)(tree, "element", (node) => {
                // Ensure we don't use react-dom elements
                // @ts-expect-error: incorrect types
                node.tagName = "html." + node.tagName;
            });
        };
    });
    async function transformMdx(props) {
        if (!matchFile(props)) {
            return props;
        }
        let { contents } = await compiler.process({
            contents: props.src,
            path: props.filename,
        });
        if (typeof contents === "string") {
            // Support member expressions in require statements:
            contents = contents.replace(/"\[\[_Expo_MemberProperty:(.*)\]\]"/g, (match, p1) => {
                return p1.replace(/\\\\/g, "\\").replace(/\\"/g, '"');
            });
        }
        props.src = getTemplate(contents);
        debug("Compiled MDX file:", props.filename, "\n", props.src);
        return props;
    }
    return { transform: transformMdx, compiler };
}
exports.createTransformer = createTransformer;
exports.transform = createTransformer().transform;
//# sourceMappingURL=metro-transformer.js.map