{"version":3,"file":"metro-transformer.js","sourceRoot":"","sources":["../src/metro-transformer.ts"],"names":[],"mappings":"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","sourcesContent":["import mdx from \"@mdx-js/mdx\";\nimport { Processor } from \"unified\";\nimport { Parent } from \"unist\";\nimport visit from \"unist-util-visit\";\n\nconst debug = require(\"debug\")(\"bacons:mdx:transform\") as typeof console.log;\n\nconst getTemplate = (rawMdxString) => {\n  const replacedShortcodes = rawMdxString.replace(\n    /= makeShortcode\\(/g,\n    \"= makeExpoMetroProvided(\"\n  );\n\n  return `import { useMDXComponents } from \"@bacons/mdx\";\n${makeExpoMetroProvidedTemplate}\n${replacedShortcodes.replace(\n  \"return <MDXLayout\",\n  \"const html = useMDXComponents();\\n  const MDXLayout = html.Wrapper;\\n  return <MDXLayout\"\n)}`;\n};\n\nconst makeExpoMetroProvidedTemplate = `\nconst makeExpoMetroProvided = name => function MDXExpoMetroComponent(props) {\n  const html = useMDXComponents();\n  if (html[name] == null) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\")\n    return <html.span {...props}/>\n  }\n  return html[name](props);\n};`;\n\nfunction isParent(node: any): node is Parent {\n  return Array.isArray(node?.children);\n}\n\nexport function createTransformer({\n  matchFile = (props) => !!props.filename.match(/\\.mdx?$/),\n  matchLocalAsset = (props) => !!props.src.match(/^[.@]/),\n  remarkPlugins = [],\n}: {\n  /**\n   * @param props Metro transform props.\n   * @returns true if the file should be transformed.\n   * @default Function that matches if a file ends with `.mdx` or `.md`.\n   */\n  matchFile?: (props: { filename: string; src: string }) => boolean;\n  /**\n   * @returns true if the src reference should be converted to a local `require`.\n   * @default Function that matches strings starting with `.` or `@`.\n   */\n  matchLocalAsset?: (props: { src: string }) => boolean;\n\n  remarkPlugins?: any[];\n} = {}) {\n  const compiler = mdx.createCompiler({ remarkPlugins }) as Processor;\n\n  // Append this final rule at the end of the compiler chain:\n  compiler.use(() => {\n    return (tree, _file) => {\n      if (isParent(tree)) {\n        const walkForImages = (node: any) => {\n          if (node.tagName === \"img\") {\n            if (matchLocalAsset(node.properties)) {\n              // Relative path should be turned into a require statement:\n              node.properties.src = `[[_Expo_MemberProperty:require(\"${node.properties.src}\")]]`;\n              // delete node.properties.src;\n            }\n          }\n          if (isParent(node)) {\n            node.children.forEach(walkForImages);\n          }\n        };\n\n        tree.children.map(walkForImages);\n      }\n\n      visit(tree, \"element\", (node) => {\n        // Ensure we don't use react-dom elements\n        // @ts-expect-error: incorrect types\n        node.tagName = \"html.\" + node.tagName;\n      });\n    };\n  });\n\n  async function transformMdx(props: { filename: string; src: string }) {\n    if (!matchFile(props)) {\n      return props;\n    }\n\n    let { contents } = await compiler.process({\n      contents: props.src,\n      path: props.filename,\n    });\n\n    if (typeof contents === \"string\") {\n      // Support member expressions in require statements:\n      contents = contents.replace(\n        /\"\\[\\[_Expo_MemberProperty:(.*)\\]\\]\"/g,\n        (match, p1) => {\n          return p1.replace(/\\\\\\\\/g, \"\\\\\").replace(/\\\\\"/g, '\"');\n        }\n      );\n    }\n\n    props.src = getTemplate(contents);\n\n    debug(\"Compiled MDX file:\", props.filename, \"\\n\", props.src);\n\n    return props;\n  }\n\n  return { transform: transformMdx, compiler };\n}\n\nexport const transform = createTransformer().transform;\n"]}